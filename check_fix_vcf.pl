#!/bin/env perl

use FindBin;
use lib "$FindBin::Bin";

use Log::Log4perl;
use Term::ProgressBar;
use VCFUtils;

use strict;

# This script tries to detect three issues frequently found in VCFs generated by GATK

# - Two calls on the same positon where the alternative field is equal '.' on both calls, indicating the sample is equal to reference. In some cases the reference sequence is reported differently in each calls (example 1,2 and 4), in others the reference sequence is exactly the same (example 3 below)   


# Example 1
# 7000000184540662        24681   .       G       .       2833.68 PASS    AC=0;AF=0.00;AN=2;DP=97;MQ=34.74;MQ0=0  GT:DP   0/0:97
# 7000000184540662        24681   .       GT      .       3830.50 PASS    AC=0;AF=0.00;AN=2;DP=97;MQ=34.74;MQ0=0  GT:DP   0/0:97

# Example 2
# 7000000184540662        24681   .       C       .       2833.68 PASS    AC=0;AF=0.00;AN=2;DP=97;MQ=34.74;MQ0=0  GT:DP   0/0:97
# 7000000184540662        24681   .       G       .       3830.50 PASS    AC=0;AF=0.00;AN=2;DP=97;MQ=34.74;MQ0=0  GT:DP   0/0:97

# Example 3
# 7000000184540662        499612  .       C       .       2297.85 PASS    AC=0;AF=0.00;AN=2;DP=80;MQ=49.65;MQ0=0  GT:DP   0/0:80
# 7000000184540662        499612  .       C       .       2452.27 PASS    AC=0;AF=0.00;AN=2;DP=82;MQ=50.08;MQ0=0  GT:DP   0/0:82

# Example 4
# 7000000184540662        24681   .       CT       .       2833.68 PASS    AC=0;AF=0.00;AN=2;DP=97;MQ=34.74;MQ0=0  GT:DP   0/0:97
# 7000000184540662        24681   .       GT       .       3830.50 PASS    AC=0;AF=0.00;AN=2;DP=97;MQ=34.74;MQ0=0  GT:DP   0/0:97


# - Polymorphism of the same kind (insertion or deletion) reported in the same position.


# Example 2 (insertion)
# 7000000184540662        24681   .       C       CG       2833.68 PASS    AC=0;AF=0.00;AN=2;DP=97;MQ=34.74;MQ0=0  GT:DP   0/0:97
# 7000000184540662        24681   .       C       CT       3830.50 PASS    AC=0;AF=0.00;AN=2;DP=97;MQ=34.74;MQ0=0  GT:DP   0/0:97

# Example 3 (deletion)
# 7000000184540662        24681   .       CG       C       2833.68 PASS    AC=0;AF=0.00;AN=2;DP=97;MQ=34.74;MQ0=0  GT:DP   0/0:97
# 7000000184540662        24681   .       CC       C       3830.50 PASS    AC=0;AF=0.00;AN=2;DP=97;MQ=34.74;MQ0=0  GT:DP   0/0:97


# - Records in disagremment for the same position (only applies to substitutions)  

# Example 1
# 7000000184540662        24681   .       C       G       2833.68 PASS    AC=0;AF=0.00;AN=2;DP=97;MQ=34.74;MQ0=0  GT:DP   0/0:97
# 7000000184540662        24681   .       C       .       3830.50 PASS    AC=0;AF=0.00;AN=2;DP=97;MQ=34.74;MQ0=0  GT:DP   0/0:97



Log::Log4perl->init( $FindBin::Bin . '/log4perl.conf' );
my $log = Log::Log4perl->get_logger();

$SIG{__WARN__} = sub {
        local $Log::Log4perl::caller_depth =
        $Log::Log4perl::caller_depth + 1;
        $log->warn( @_ );
};

$SIG{__DIE__} = sub {
        if($^S) {
        	# We're in an eval {} and don't want log
        	# this message but catch it later
        	return;
        }
        $Log::Log4perl::caller_depth++;
        $log->logexit( @_ );
};

my $usage = "check_and_fix_vcf.pl <vcf_list> <new vcf_list>";

$log->logexit( $usage ) if ( scalar(@ARGV) != 2 );


####################
# Read VCF list

my $vcf_file_list 		=  $ARGV[0];
my $new_vcf_file_list 		=  $ARGV[1];

my @vcf_list;

my ( $refSampleNames, $refVCFList, $refNumCalls )  = VCFUtils::read_vcf_list( $vcf_file_list, $log );
@vcf_list = @{$refVCFList};



####################
# Read and Write new VCFs

my @new_num_calls;

# Add suffix .pol_sites.vcf
my @new_vcf_list = map { 
		my $vcf_file = $_;	

		$vcf_file =~ s{.*/}{};
				
		if ( $vcf_file =~ /.vcf$/ ){
			$vcf_file =~ s/.vcf$/.retained.vcf/;
			$vcf_file;
		}else{
			$vcf_file .=  ".retained.vcf";
			$vcf_file;
		}
	} @vcf_list;

	

my @double_calls_files = map { 
		my $vcf_file = $_;	

		$vcf_file =~ s{.*/}{};
				
		if ( $vcf_file =~ /.vcf$/ ){
			$vcf_file =~ s/.vcf$/.double_calls/;
			$vcf_file;
		}else{
			$vcf_file .=  ".double_calls";
			$vcf_file;
		}
	} @vcf_list;	

for( my $ind = 0; $ind < scalar(@vcf_list); $ind++ ){
	my $vcf_file = $vcf_list[ $ind ];
	my $vcf_output_file = $new_vcf_list[ $ind ];
	
	my $vcf_file_num = $ind + 1;
	my $progress_eta = $refNumCalls->[ $ind ];

	$log->info( "Generating a copy of the VCF file $vcf_file without double calls [File num.: $vcf_file_num] ...\n" );
	
	# Only using progress bar if the number of insert and/or update lines
	# is higher than 100k
	my $progress;
	if( $progress_eta >= 100000 ){
		$progress = Term::ProgressBar->new( { count => $progress_eta, remove => 1 });
	}
	
	open IN, "$vcf_file" or $log->fatal( "Unable to open file $vcf_file" ) ;
	open OUT, ">$vcf_output_file" or $log->fatal( "Unable to open file $vcf_output_file" ) ;

		
	open my $fh_double_calls, ">" . $double_calls_files[ $ind ]  
		or $log->fatal( "Unable to open file " . $double_calls_files[ $ind ] ) ;

		
	my $cont = 0;
	my $num_calls_left = 0;
	
	my $last_chrom = '';
	my $last_pos   = '';
	my $last_id    = '';
	my $last_ref   = '';
	my $last_alt   = '';
		
	my %calls;	
	
	while( <IN> ){
		my $line = $_;
		if( $line =~ /^#/ ){
			print OUT $line;
			next;
		}
  
		my ( $chrom, $pos, $id, $ref, $alt, $qual ) = split '\t', $line;		

		# Clean vectors if file handler
		# points to a record reporting 
		# a different chrom or position 
		if( 	$chrom ne $last_chrom ||
			$pos != $last_pos  ){
		
		
			# Foreach variation type: same, substitution, insertion and deletion
			foreach my $refCallArr ( values %calls ){
		
				next if not defined $refCallArr;
				
				if( scalar( @{$refCallArr} ) == 1 ){				
					print OUT $refCallArr->[0]->{line};
					$num_calls_left++;
				}elsif( scalar( @{$refCallArr} ) > 1 ){
					my $highest_qual = get_highest_qual( $refCallArr, $fh_double_calls);
					print OUT $highest_qual;
					$num_calls_left++;
				}
			}
				
		
			%calls= undef;
		
		}
		
		
		# Evaluating the variation type
		my $raw_var_length = length( $alt ) - length( $ref );
		my $has_alleles  = ( $alt =~ "," ); 				
		
		# If same (alt=.) or subtitutions
		if ( $alt eq '.' || $raw_var_length == 0 || $has_alleles ) {
			push @{$calls{substitutions}}, { line => $line, qual => $qual };
		}
		
		# if deletions
		elsif ( $raw_var_length < 0 ) {
			push @{$calls{deletions}}, { line => $line, qual => $qual };
		}
		
		# if insertions
		elsif ( $raw_var_length > 0 ) {
			push @{$calls{insertions}}, { line => $line, qual => $qual };
		}else{
			$log->logexit(	"Unable to identify variation type " .
					"(same, substitution,insertion or deletion)" .
					" reported on line:\n$line\n" );
		}		
				
		( $last_chrom, $last_pos, $last_id, $last_ref, $last_alt ) = ( $chrom, $pos, $id, $ref, $alt );
	
		$progress->update( $cont ) if ( defined $progress && $cont % 1000 == 0 );

		$cont++;
	}
	
	# Foreach variation type: same, substitution, insertion and deletion
	foreach my $refCallArr ( values %calls ){
	
		next if not defined $refCallArr;
			
		if( scalar( @{$refCallArr} ) == 1 ){				
			print OUT $refCallArr->[0]->{line};
			$num_calls_left++;
		}elsif( scalar( @{$refCallArr} ) > 1 ){
			my $highest_qual = get_highest_qual( $refCallArr, $fh_double_calls );
			print OUT $highest_qual;
			$num_calls_left++;
		}
	}
	
	my $num_removed_calls = $cont - $num_calls_left; 
	$new_num_calls[ $ind ] = $num_calls_left;
	
	print "VCF file $vcf_file:\n";
	print "Num. of calls:\n";
	print "\tOriginal file: $cont\n";
	print "\tRetained: $num_calls_left (" . $new_vcf_list[ $ind ] .")\n";
	print "\tRemoved: $num_removed_calls\n";
	print "List of double calls: " . $double_calls_files[ $ind ] . "\n\n";
	
	close(IN);
	close(OUT);
	close($fh_double_calls);
}

VCFUtils::write_vcf_list( $new_vcf_file_list , $refSampleNames, \@new_vcf_list, \@new_num_calls, $log );
exit(0);


sub get_highest_qual{
	my ($refArr, $log_file) = @_;
	
	print {$log_file} "CANDIDATES:\n";
	map {print {$log_file} "\t" . $_->{line} } @{$refArr};
	
	my @sorted = sort { $b->{qual} <=> $a->{qual} } @{$refArr};

	my $highest = $sorted[0]->{line};
	my $h_qual  = $sorted[0]->{qual};
	
	print {$log_file} "CHOSEN (Highest quality): \n\t$highest\n\n";
	return $highest;
		
}
